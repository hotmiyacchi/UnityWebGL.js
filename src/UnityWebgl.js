import EventSystem from './Events.js'

const isPlainObject = arg => Object.prototype.toString.call(arg) === '[object Object]'

/**
 * The unity loader
 * @param {string} src loaderUrl
 * @param {object} param callback
 * @returns 
 */
function unityLoader(src, { resolve, reject }) {
  if (!src) {
    reject && reject(new Error('UnityWebgl: loaderUrl not found.'))
    return null
  }

  if (typeof window.createUnityInstance === 'function') {
    // console.warn('UnityWebgl: Unity Loader already exists')
    resolve && resolve()
  }

  function handler(code) {
    if (code === 'ready') {
      resolve && resolve()
    } else {
      reject && reject(new Error(`'UnityWebgl: ${src}' loading failure.`))
    }
  }

  let script = document.querySelector(`script[src="${src}"]`)
  if (script === null) {
    script = document.createElement('script')
    script.src = src
    script.async = true
    script.setAttribute('data-status', 'loading')

    document.body.appendChild(script)

    const setAttributeFromEvent = function(event) {
      const _status = event.type === 'load' ? 'ready' : 'error'
      script?.setAttribute('data-status', _status)
      // handler(_status)
    }

    script.addEventListener('load', setAttributeFromEvent)
    script.addEventListener('error', setAttributeFromEvent)
  } else {
    handler(script.getAttribute('data-status'))
  }

  const setStateFromEvent = function(event) {
    handler(event.type === 'load' ? 'ready' : 'error')
  }

  script.addEventListener('load', setStateFromEvent)
  script.addEventListener('error', setStateFromEvent)

  return function() {
    if (script) {
      script.removeEventListener('load', setStateFromEvent)
      script.removeEventListener('error', setStateFromEvent)
      document.body.removeChild(script)
    }
  }
}

/**
 * generate UnityInstance parameters
 * @param {object} unityContext 
 * @param {object} unityProps 
 * @returns 
 */
function generateUnityInstanceParameters(unity) {
  const unityParameters = { ...unity.config }
  
  unityParameters.print = function (message) {
    unity.emit('debug', message)
  }

  unityParameters.printErr = function (message) {
    unity.emit('error', message)
  }

  return unityParameters
}

/**
 * get CanvasElement
 * @param {string | HTMLCanvasElement} canvas 
 * @returns 
 */
function queryCanvas(canvas) {
  if (canvas instanceof HTMLCanvasElement) {
    return canvas
  } else if (typeof canvas === 'string') {
    return document.querySelector(canvas)
  } else {
    // console.warn('UnityWebgl: CanvasElement not found.')
    return null
  }
}

const DefaultConfig = {
  streamingAssetsUrl: 'StreamingAssets',
  companyName: 'Unity.com',
  productName: 'Unity'
}

export default class UnityWebgl extends EventSystem {
  unityLoader = null
  canvasElement = null
  unityInstance = null
  
  /**
   * Creates a new Unity Context instance
   * @param {object} options The Unity Config
   * @param {string} options.loaderUrl The url to the build json file generated by Unity
   * @param {string} options.dataUrl The url to the build data file generated by Unity
   * @param {string} options.frameworkUrl The url to the framework file generated by Unity
   * @param {string} options.codeUrl The url to the unity code file generated by Unity
   * @param {string} options.streamingAssetsUrl The url where the streaming assets can be found
   * @param {string} options.companyName The applications company name
   * @param {string} options.productName The applications product name
   * @param {string} options.productVersion The applications product version
   * @param {WebGLContextAttributes} options.webglContextAttributes This object allow you to configure WebGLRenderingContext creation options
   * @param {number} options.devicePixelRatio Uncomment this to override low DPI rendering on high DPI displays. see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
   * @param {boolean} options.matchWebGLToCanvasSize Uncomment this to separately control WebGL canvas render size and DOM element size. see https://issuetracker.unity3d.com/issues/webgl-builds-dont-allow-separate-control-on-canvas-render-buffer-size
   */
  constructor(canvas, options = {}) {
    super()

    if (isPlainObject(canvas)) {
      this.config = Object.assign({}, DefaultConfig, canvas)
    } else {
      this.config = Object.assign({}, DefaultConfig, options)
      const _canvas = queryCanvas(canvas)
      if (_canvas) {
        this.create(_canvas)
      }
    }
  }
  
  /**
   * initialization
   * @param {object|string} canvas HTMLCanvasElement
   */
  create(canvas) {
    if (this.unityInstance && this.canvasElement && this.unityLoader) {
      console.warn('UnityWebgl: Unity Instance already exists')
      return false
    }

    const canvasEl = queryCanvas(canvas)
    if (!canvasEl) {
      console.warn('UnityWebgl: CanvasElement not found.')
      return false
    }
    this.canvasElement = canvasEl
    
    const ctx = this
    const config = generateUnityInstanceParameters(this)

    this.unityLoader = unityLoader(config.loaderUrl, {
      resolve() {
        try {
          window.createUnityInstance(
            canvasEl,
            config,
            (val) => ctx._setProgression(val)
          ).then(unity => {
            ctx.unityInstance = unity 
            ctx.emit('created', unity)
          }).catch(err => {
            ctx.unityInstance = null
            ctx.emit('error', err)
          })
        } catch (err) {
          ctx.unityInstance = null
          ctx.emit('error', err)
        }
      },
      reject(err) {
        console.error('UnityWebgl: ', err?.message)
      }
    })
  }

  /**
   * set Progression
   * @param {number} val progress
   */
  _setProgression(val) {
    if (val === 1) {
      this.emit('loaded')
    }
    this.emit('progress', val)
  }
  
  /**
   * Sends a message to the UnityInstance to invoke a public method.
   * @param {string} objectName Unity scene name.
   * @param {string} methodName public method name.
   * @param {any} params an optional method parameter.
   * @returns 
   */
  send(objectName, methodName, params) {
    if (this.unityInstance !== null) {
      if (params === undefined || params === null) {
        this.unityInstance.SendMessage(objectName, methodName)
      } else {
        const _params = typeof params === 'object' ? JSON.stringify(params) : params
        this.unityInstance.SendMessage(objectName, methodName, _params)
      }
    }
    return this
  }
  
  /**
   * Asynchronously ask for the pointer to be locked on current canvas. To track
   * the success or failure of the request, it is necessary to listen for the
   * pointerlockchange and pointerlockerror events at the Document level.
   * @public
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/requestPointerLock
   */
  requestPointerLock() {
    if (this.canvasElement !== null) {
      this.canvasElement.requestPointerLock()
    }
  }
  
  /**
   * Takes a screenshot of the canvas and returns a data URL containing image
   * data. The image data is in .png format unless otherwise specified.
   * @param {string} dataType The image format of the screenshot, ["image/png" | "image/jpeg" | "image/webp"]
   * @param {number} quality The quality of the jpg or webp screenshot
   * @returns a data URL containing image data of a snapshot of the canvas
   */
  takeScreenshot(dataType, quality) {
    if (this.canvasElement !== null) {
      if (this.config.webglContextAttributes?.preserveDrawingBuffer !== true) {
        console.warn("Taking a screenshot requires 'preserveDrawingBuffer'.")
      }
      return this.canvasElement.toDataURL(dataType, quality)
    }
    return null
  }
  
  /**
   * Enables or disabled the Fullscreen mode of the Unity Instance.
   * @param {boolean} enabled 
   */
  setFullscreen(enabled) {
    if (this.unityInstance !== null) {
      this.unityInstance.SetFullscreen(enabled ? 1 : 0)
    }
  }
  
  /**
   * Quits the Unity Instance and clears it from memory.
   */
  quitUnityInstance() {
    if (this.unityInstance !== null) {
      this.unityInstance.Quit().then(() => {
        this.unityInstance = null
        this.emit('destroyed')
      })
    }
  }
  
  /**
   * Destroy Unity Instance
   */
  destroy() {
    if (this.unityLoader) {
      this.unityLoader()
      this.unityLoader = null
    }
    this.quitUnityInstance()
  }
}
